<!doctype html><html lang=zh-hans><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Hugo æºç é˜…è¯» - Kagami Theme</title>
<meta name=description content="WIP ä¸€ã€æ¦‚è¿° 1.1 ç›®å½•ç»“æ„ &mldr; äºŒã€ç¨‹åºæµç¨‹ 2.1 æµç¨‹å®šä¹‰ 2.1.1 é”™è¯¯çŠ¶æ€ç  func main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(&#34;&#34;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } } os.Exit(-1) ç¨‹åºçš„é€€å‡ºçŠ¶æ€ç ä¸åœ¨ 0~255 ä¹‹é—´ï¼Œä¼šè‡ªåŠ¨åšè½¬æ¢ï¼Œ">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/hugo-theme-kagami/bundle.css?v=1634282199" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=/favicon.ico><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://mayocream.github.io/hugo-theme-kagami/posts/hugo-source-code-reading/><meta property="og:title" content="Hugo æºç é˜…è¯»">
<meta property="og:description" content="WIP ä¸€ã€æ¦‚è¿° 1.1 ç›®å½•ç»“æ„ &mldr; äºŒã€ç¨‹åºæµç¨‹ 2.1 æµç¨‹å®šä¹‰ 2.1.1 é”™è¯¯çŠ¶æ€ç  func main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(&#34;&#34;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } } os.Exit(-1) ç¨‹åºçš„é€€å‡ºçŠ¶æ€ç ä¸åœ¨ 0~255 ä¹‹é—´ï¼Œä¼šè‡ªåŠ¨åšè½¬æ¢ï¼Œ">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mayocream.github.io/hugo-theme-kagami/posts/hugo-source-code-reading/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-12-10T00:00:00+00:00">
<meta property="article:modified_time" content="2020-12-10T00:00:00+00:00"><meta property="og:site_name" content="My cool site">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'ğŸŒ“',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/hugo-theme-kagami/posts/>Posts</a>
<a class=page-link href=/hugo-theme-kagami/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://mayocream.github.io/hugo-theme-kagami/>Kagami Theme</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh itemprop="name headline">Hugo æºç é˜…è¯»</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<blockquote>
<p>WIP</p>
</blockquote>
<h2 id=ä¸€æ¦‚è¿°>ä¸€ã€æ¦‚è¿°</h2>
<h3 id=11-ç›®å½•ç»“æ„>1.1 ç›®å½•ç»“æ„</h3>
<p>&mldr;</p>
<h2 id=äºŒç¨‹åºæµç¨‹>äºŒã€ç¨‹åºæµç¨‹</h2>
<h3 id=21-æµç¨‹å®šä¹‰>2.1 æµç¨‹å®šä¹‰</h3>
<h4 id=211-é”™è¯¯çŠ¶æ€ç >2.1.1 é”™è¯¯çŠ¶æ€ç </h4>
<pre><code class=language-go>func main() {
	resp := commands.Execute(os.Args[1:])

	if resp.Err != nil {
		if resp.IsUserError() {
			resp.Cmd.Println(&quot;&quot;)
			resp.Cmd.Println(resp.Cmd.UsageString())
		}
		os.Exit(-1)
	}
}
</code></pre>
<p><code>os.Exit(-1)</code> ç¨‹åºçš„é€€å‡ºçŠ¶æ€ç ä¸åœ¨ 0~255 ä¹‹é—´ï¼Œä¼šè‡ªåŠ¨åšè½¬æ¢ï¼Œè½¬æ¢çš„è§„åˆ™å¦‚ä¸‹<sup>[1]</sup>ï¼š</p>
<ul>
<li>å½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºè´Ÿæ•°:</li>
</ul>
<pre><code class=language-fallback>256 - (|code| % 256)
</code></pre>
<ul>
<li>å½“æŒ‡å®šçš„é€€å‡ºæ—¶çŠ¶æ€ç ä¸ºæ­£æ•°:</li>
</ul>
<pre><code class=language-fallback>code % 256
</code></pre>
<p>ç”±æ­¤ç¨‹åºé€€å‡ºçš„çŠ¶æ€ç ä¸º 255ã€‚</p>
<h4 id=212-cli-å‘½ä»¤>2.1.2 CLI å‘½ä»¤</h4>
<pre><code class=language-go>// commands/commands.go
func (b *commandsBuilder) addAll() *commandsBuilder {
   b.addCommands(
      b.newServerCmd(),
      newVersionCmd(),
      newEnvCmd(),
      b.newConfigCmd(),
      newCheckCmd(),
      b.newDeployCmd(),
      b.newConvertCmd(),
      b.newNewCmd(),
      b.newListCmd(),
      newImportCmd(),
      newGenCmd(),
      createReleaser(),
      b.newModCmd(),
   )

   return b
}
</code></pre>
<p>æ‰€æœ‰çš„ cmd handler ç»§æ‰¿è‡ª basecmdï¼Œå®ç°äº† cmder æ¥å£ï¼š</p>
<pre><code class=language-go>// commands/helpers.go
type cmder interface {
	flagsToConfig(cfg config.Provider)
	getCommand() *cobra.Command
}
</code></pre>
<p>
<figure class=image>
<img src=images/hugo-impl.png alt loading=lazy>
</figure></p>
<pre><code class=language-go>// commands/commands.go
func (b *commandsBuilder) addAll() *commandsBuilder {
	b.addCommands(
		b.newServerCmd(),
		newVersionCmd(),
		newEnvCmd(),
		b.newConfigCmd(),
		newCheckCmd(),
		b.newDeployCmd(),
		b.newConvertCmd(),
		b.newNewCmd(),
		b.newListCmd(),
		newImportCmd(),
		newGenCmd(),
		createReleaser(),
		b.newModCmd(),
	)

	return b
}

func (b *commandsBuilder) build() *hugoCmd {
	// æ·»åŠ ä¸» hugo å‘½ä»¤
	h := b.newHugoCmd()
	// å°†å‘½ä»¤æ•°ç»„æ·»åŠ è¿› cobra çš„ Root Command ä¸­, ä½œä¸ºå­å‘½ä»¤
	addCommands(h.getCommand(), b.commands...)
	return h
}
</code></pre>
<h3 id=22-æ¸²æŸ“åˆå§‹åŒ–>2.2 æ¸²æŸ“åˆå§‹åŒ–</h3>
<blockquote>
<p>æ‰§è¡Œ Hugo å‘½ä»¤æ—¶è¿›è¡Œçš„åˆå§‹åŒ–åŠ è½½</p>
</blockquote>
<pre><code class=language-go>// åˆ›å»º hugoCmd å°è£…å—
func (b *commandsBuilder) newHugoCmd() *hugoCmd {
	cc := &amp;hugoCmd{}

	cc.baseBuilderCmd = b.newBuilderCmd(&amp;cobra.Command{
		Use:   &quot;hugo&quot;,
		Short: &quot;hugo builds your site&quot;,
		Long: `hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.`,

		// æ‰§è¡Œæ¸²æŸ“æ“ä½œ
		RunE: func(cmd *cobra.Command, args []string) error {
			// è®°å½•å…¨å±€æ“ä½œè€—æ—¶
			defer cc.timeTrack(time.Now(), &quot;Total&quot;)
			cfgInit := func(c *commandeer) error {
				if cc.buildWatch {
					// å¦‚æœå¼€å¯äº† watch æ¨¡å¼åˆ™å…³é—­åŠ¨æ€é‡è½½
					c.Set(&quot;disableLiveReload&quot;, true)
				}
				return nil
			}

			// åˆå§‹åŒ–é…ç½®
			c, err := initializeConfig(true, cc.buildWatch, &amp;cc.hugoBuilderCommon, cc, cfgInit)
			if err != nil {
				return err
			}
			cc.c = c

			// ç¼–è¯‘æ“ä½œ
			return c.build()
		},
	})
   
    ...
</code></pre>
<h4 id=221-é…ç½®æ–‡ä»¶åŠ è½½>2.2.1 é…ç½®æ–‡ä»¶åŠ è½½</h4>
<pre><code class=language-go>// hugolib/config.go

	for _, configDir := range configDirs {
		err := afero.Walk(sourceFs, configDir, func(path string, fi os.FileInfo, err error) error {
			if fi == nil || err != nil {
				return nil
			}

			if fi.IsDir() {
				dirnames = append(dirnames, path)
				return nil
			}

			// æ£€æŸ¥æ–‡ä»¶åç¼€æ˜¯å¦æ˜¯æ”¯æŒçš„æ ¼å¼
			if !config.IsValidConfigFilename(path) {
				return nil
			}

			// æ–‡ä»¶å, ç§»é™¤æ–‡ä»¶åç¼€
			name := helpers.Filename(filepath.Base(path))

			// åŠ è½½æ–‡ä»¶å†…å®¹åˆ° map
			item, err := metadecoders.Default.UnmarshalFileToMap(sourceFs, path)
			if err != nil {
				return l.wrapFileError(err, path)
			}

			var keyPath []string

			// å¦‚æœä¸æ˜¯ hugo çš„ config æ–‡ä»¶
			if name != &quot;config&quot; {
				// Can be params.jp, menus.en etc.
				// å¦‚æœæ–‡ä»¶è¿˜æœ‰åç¼€, å¯èƒ½æ˜¯è¯­è¨€åç¼€
				name, lang := helpers.FileAndExtNoDelimiter(name)

				keyPath = []string{name}

				// å¦‚æœè¯­è¨€åç¼€å­˜åœ¨
				if lang != &quot;&quot; {
					// å¡«å……è¯­è¨€æ–‡ä»¶å¤¹è·¯å¾„
					keyPath = []string{&quot;languages&quot;, lang}
					switch name {
					case &quot;menu&quot;, &quot;menus&quot;:
						keyPath = append(keyPath, &quot;menus&quot;)
					case &quot;params&quot;:
						keyPath = append(keyPath, &quot;params&quot;)
					}
				}
			}

			root := item
			if len(keyPath) &gt; 0 {
				root = make(map[string]interface{})
				m := root

				// éå†å½¢æˆå±‚çº§å…³ç³»

				// éå†è¯­è¨€æ–‡ä»¶å¤¹çš„è·¯å¾„
				// i ä» 0 å¼€å§‹
				for i, key := range keyPath {
					// å¦‚æœ i &gt;= æœ€åä¸€ä¸ªå…ƒç´ çš„ index
					if i &gt;= len(keyPath)-1 {
						// å°†æ–‡ä»¶å†…å®¹å¡«å……åˆ° key ä¸‹é¢
						m[key] = item
					} else {
						nm := make(map[string]interface{})
						m[key] = nm
						m = nm
					}
				}
			}

			// Migrate menu =&gt; menus etc.
			config.RenameKeys(root)

			// åˆå¹¶é…ç½®æ–‡ä»¶
			if err := v.MergeConfigMap(root); err != nil {
				return l.wrapFileError(err, path)
			}

			return nil
		})
</code></pre>
<p>éå†é…ç½®æ–‡ä»¶å¤¹ã€ä»¥åŠåŠ è½½é…ç½®æ–‡ä»¶ï¼ˆyaml/toml/json åç¼€ï¼‰åˆ° Map ä¸­ï¼Œä½¿ç”¨ Viper çš„ <code>MergeConfigMap</code> è½½å…¥é…ç½®ï¼ŒåŒ…å«è¯­è¨€ã€èœå•é…ç½®ã€‚</p>
<pre><code class=language-go>// hugolib/hugo_sites.go
// åˆ›å»º sites çš„é…ç½®
func createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) {
	var sites []*Site

	// è·å–å¤šè¯­è¨€é…ç½®
	languages := getLanguages(cfg.Cfg)

	for _, lang := range languages {
		if lang.Disabled {
			continue
		}
		var s *Site
		var err error
		cfg.Language = lang
		// ä¸ºæ¯ä¸ªè¯­è¨€åˆ›å»ºä¸€ä¸ª site
		s, err = newSite(cfg)

		if err != nil {
			return nil, err
		}

		sites = append(sites, s)
	}

	return sites, nil
}
</code></pre>
<p>ä¸ºæ¯ä¸ªè¯­è¨€ç”Ÿæˆä¸€ä¸ª Siteã€‚</p>
<h4 id=222-å†…å®¹åŠ è½½>2.2.2 å†…å®¹åŠ è½½</h4>
<p>æ³¨å†Œå›è°ƒå‡½æ•°:</p>
<pre><code class=language-go>// hugolib/site.go
// åˆå§‹åŒ–
func (s *Site) prepareInits() {
	s.init = &amp;siteInit{}

	var init lazy.Init

	// å›è°ƒå‡½æ•°
	s.init.prevNext = init.Branch(func() (interface{}, error) {
		// è·å– pages
		regularPages := s.RegularPages()
		for i, p := range regularPages {
			np, ok := p.(nextPrevProvider)
			if !ok {
				continue
			}

			pos := np.getNextPrev()
			if pos == nil {
				continue
			}

			pos.nextPage = nil
			pos.prevPage = nil

			if i &gt; 0 {
				pos.nextPage = regularPages[i-1]
			}

			if i &lt; len(regularPages)-1 {
				pos.prevPage = regularPages[i+1]
			}
		}
		return nil, nil
	})

	s.init.prevNextInSection = init.Branch(func() (interface{}, error) {
		var sections page.Pages
		s.home.treeRef.m.collectSectionsRecursiveIncludingSelf(pageMapQuery{Prefix: s.home.treeRef.key}, func(n *contentNode) {
			sections = append(sections, n.p)
		})

		setNextPrev := func(pas page.Pages) {
			for i, p := range pas {
				np, ok := p.(nextPrevInSectionProvider)
				if !ok {
					continue
				}

				pos := np.getNextPrevInSection()
				if pos == nil {
					continue
				}

				pos.nextPage = nil
				pos.prevPage = nil

				if i &gt; 0 {
					pos.nextPage = pas[i-1]
				}

				if i &lt; len(pas)-1 {
					pos.prevPage = pas[i+1]
				}
			}
		}

		for _, sect := range sections {
			treeRef := sect.(treeRefProvider).getTreeRef()

			var pas page.Pages
			treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {
				pas = append(pas, c.p)
			})
			page.SortByDefault(pas)

			setNextPrev(pas)
		}

		// The root section only goes one level down.
		treeRef := s.home.getTreeRef()

		var pas page.Pages
		treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) {
			pas = append(pas, c.p)
		})
		page.SortByDefault(pas)

		setNextPrev(pas)

		return nil, nil
	})

	s.init.menus = init.Branch(func() (interface{}, error) {
		s.assembleMenus()
		return nil, nil
	})

	s.init.taxonomies = init.Branch(func() (interface{}, error) {
		err := s.pageMap.assembleTaxonomies()
		return nil, err
	})
}
</code></pre>
<h2 id=ä¸‰ç»†ææœ«èŠ‚>ä¸‰ã€ç»†ææœ«èŠ‚</h2>
<h3 id=31-interface-å®ç°çº¦æŸ>3.1 interface å®ç°çº¦æŸ</h3>
<p>ä»£ç ä¸­æœ‰å¤šå¤„ä½¿ç”¨å¦‚ä¸‹æ–¹å¼åœ¨ç¼–è¯‘æ—¶çº¦æŸ interface è¢«å®ç°ã€‚</p>
<pre><code class=language-go>var _ cmder = (*newCmd)(nil)
</code></pre>
<p>å…¶ä»–å¼€æºé¡¹ç›®ä¸­æœ‰ä¹Ÿæœ‰è¿™ç§å†™æ³•çš„ï¼š</p>
<pre><code class=language-go>var _ cmder = &amp;newCmd{}
var _ cmder = newCmd{}
</code></pre>
<h3 id=32-é˜²æŠ–>3.2 é˜²æŠ–</h3>
<pre><code class=language-go>package debounce

import (
	&quot;sync&quot;
	&quot;time&quot;
)

// New returns a debounced function that takes another functions as its argument.
// This function will be called when the debounced function stops being called
// for the given duration.
// The debounced function can be invoked with different functions, if needed,
// the last one will win.
func New(after time.Duration) func(f func()) {
	d := &amp;debouncer{after: after}

	return func(f func()) {
		d.add(f)
	}
}

type debouncer struct {
	mu    sync.Mutex
	after time.Duration
	timer *time.Timer
}

func (d *debouncer) add(f func()) {
	d.mu.Lock()
	defer d.mu.Unlock()

    // å¦‚æœæ­£åœ¨å»¶æ—¶ä¸­ï¼Œå–æ¶ˆå½“å‰å»¶æ—¶ï¼Œæ·»åŠ æ–°çš„å»¶æ—¶
	if d.timer != nil {
		d.timer.Stop()
	}
	d.timer = time.AfterFunc(d.after, f)
}
</code></pre>
<p>é˜²æŠ–å‡½æ•°çš„ä½¿ç”¨ç±»ä¼¼ React Hooksã€‚</p>
<pre><code class=language-go>f := func()
run := debounce.New(f)
run()
</code></pre>
<p>åœ¨ Istio æºç ä¸­ï¼Œå¤„ç† XDS æ¨æµæ—¶ä¹Ÿä¼šè¿›è¡Œé˜²æŠ–å¤„ç†ã€‚</p>
<h3 id=32-lifo-é˜Ÿåˆ—>3.2 LIFO é˜Ÿåˆ—</h3>
<pre><code class=language-go>// LIFO é˜Ÿåˆ—ï¼Œæº¢å‡ºçš„å…ƒç´ ä¼šä»é¡¶éƒ¨ç§»é™¤
// æ²¡æœ‰ä¸»åŠ¨åˆ é™¤å…ƒç´ çš„æ–¹æ³•
// EvictingStringQueue is a queue which automatically evicts elements from the head of
// the queue when attempting to add new elements onto the queue and it is full.
// This queue orders elements LIFO (last-in-first-out). It throws away duplicates.
// Note: This queue currently does not contain any remove (poll etc.) methods.
type EvictingStringQueue struct {
	size int
	vals []string // å‚¨å­˜çœŸå®çš„æ•°æ®
	set  map[string]bool // è¡¨ç¤ºæ˜¯å¦å·²ç»å­˜åœ¨
	mu   sync.Mutex
}

// NewEvictingStringQueue creates a new queue with the given size.
func NewEvictingStringQueue(size int) *EvictingStringQueue {
	return &amp;EvictingStringQueue{size: size, set: make(map[string]bool)}
}

// Add adds a new string to the tail of the queue if it's not already there.
func (q *EvictingStringQueue) Add(v string) {
	q.mu.Lock()
	// å·²ç»å­˜åœ¨
	if q.set[v] {
		q.mu.Unlock()
		return
	}

	// æ•°é‡è¾¾åˆ°æœ€å¤§é™åˆ¶
	if len(q.set) == q.size {
		// Full
		// ç§»é™¤äº† 0 å·å…ƒç´ çš„å ä½ç¬¦
		delete(q.set, q.vals[0])
		// :0 å–ç©ºæ•°ç»„ï¼Œ1:å–ä¸åŒ…å«ç¬¬ä¸€ä¸ªå…ƒç´ çš„å…¶ä½™å…ƒç´ 
		// ç§»é™¤äº†æ•°ç»„ 0 å·å…ƒç´ 
		q.vals = append(q.vals[:0], q.vals[1:]...)
	}
	// è¡¨ç¤ºå­˜åœ¨
	q.set[v] = true
	// æœ€æ–°æ’å…¥çš„å€¼åœ¨æ•°ç»„æœ€å
	// æ˜¯é˜Ÿåˆ—ç»“æ„
	q.vals = append(q.vals, v)
	q.mu.Unlock()
}

// Contains returns whether the queue contains v.
func (q *EvictingStringQueue) Contains(v string) bool {
	q.mu.Lock()
	defer q.mu.Unlock()
	return q.set[v]
}

// Peek looks at the last element added to the queue.
func (q *EvictingStringQueue) Peek() string {
	q.mu.Lock()
	l := len(q.vals)
	// å¤„ç†è¾¹ç•Œæ¡ä»¶
	if l == 0 {
		q.mu.Unlock()
		return &quot;&quot;
	}
	// å–æœ€åä¸€ä¸ªå…ƒç´ 
	elem := q.vals[l-1]
	q.mu.Unlock()
	return elem
}

// PeekAll looks at all the elements in the queue, with the newest first.
func (q *EvictingStringQueue) PeekAll() []string {
	q.mu.Lock()
	vals := make([]string, len(q.vals))
	copy(vals, q.vals)
	q.mu.Unlock()
	// i ä»å¤´å¼€å§‹å¾ªç¯ j ä»å°¾å¾ªç¯
	// äº¤æ¢ i j å…ƒç´ ä½ç½®
	// æ•°ç»„ reverse
	// æœ€åæ’å…¥çš„åœ¨æœ€å‰é¢
	for i, j := 0, len(vals)-1; i &lt; j; i, j = i+1, j-1 {
		vals[i], vals[j] = vals[j], vals[i]
	}
	return vals
}

// PeekAllSet returns PeekAll as a set.
func (q *EvictingStringQueue) PeekAllSet() map[string]bool {
	all := q.PeekAll()
	set := make(map[string]bool)
	for _, v := range all {
		set[v] = true
	}

	return set
}
</code></pre>
<h3 id=33-åŒæ­¥ä¿¡å·é‡>3.3 åŒæ­¥ä¿¡å·é‡</h3>
<p><code>golang.org/x/sync/semaphore</code> æ‰©å±•åŒæ­¥åŸè¯­ã€‚</p>
<h3 id=34-command>3.4 Command</h3>
<h4 id=341-cli-è‡ªåŠ¨è¡¥å…¨>3.4.1 CLI è‡ªåŠ¨è¡¥å…¨</h4>
<p>
<figure class=image>
<img src=images/hugo-cli.png alt loading=lazy>
</figure></p>
<p>Hugo çš„ä½¿ç”¨æ–¹å¼æœ‰ä¸¤ç§ï¼š</p>
<pre><code class=language-go>// &quot;-config&quot; flag è‡ªåŠ¨è¡¥å…¨æŒ‡å®šåç¼€æ–‡ä»¶å
_ = cc.cmd.PersistentFlags().SetAnnotation(&quot;config&quot;, cobra.BashCompFilenameExt, config.ValidConfigFileExtensions)

// &quot;-source&quot; flag è‡ªåŠ¨è¡¥å…¨å­æ–‡ä»¶å¤¹å
cmd.PersistentFlags().SetAnnotation(&quot;source&quot;, cobra.BashCompSubdirsInDir, []string{})
</code></pre>
<h3 id=35-å¹¶å‘æ§åˆ¶>3.5 å¹¶å‘æ§åˆ¶</h3>
<h4 id=351-ç¼“å†²é€šé“æ§åˆ¶å¹¶å‘>3.5.1 ç¼“å†²é€šé“æ§åˆ¶å¹¶å‘</h4>
<pre><code class=language-go>// common/para/para.go
// Package para implements parallel execution helpers.
package para

import (
	&quot;context&quot;

	&quot;golang.org/x/sync/errgroup&quot;
)

// Workers configures a task executor with the most number of tasks to be executed in parallel.
type Workers struct {
	sem chan struct{}
}

// Runner wraps the lifecycle methods of a new task set.
//
// Run wil block until a worker is available or the context is cancelled,
// and then run the given func in a new goroutine.
// Wait will wait for all the running goroutines to finish.
type Runner interface {
	Run(func() error)
	Wait() error
}

type errGroupRunner struct {
	*errgroup.Group
	w   *Workers
	ctx context.Context
}

func (g *errGroupRunner) Run(fn func() error) {
	select {
	// åˆ†é…ä¸€ä¸ªä¿¡å·, å¦‚æœ chan è¢«å…³é—­åˆ™é€€å‡º
	case g.w.sem &lt;- struct{}{}:
	case &lt;-g.ctx.Done():
		return
	}

	g.Go(func() error {
		err := fn()
		// æ‰§è¡Œå®Œåæ¶ˆè´¹ä¿¡å·é‡, é€šè¿‡ç¼“å­˜é€šé“ä¿è¯å¹¶å‘æ‰§è¡Œçš„åç¨‹æ•°é‡
		&lt;-g.w.sem
		return err
	})
}

// New creates a new Workers with the given number of workers.
func New(numWorkers int) *Workers {
	return &amp;Workers{
		// ç¼“å†²é€šé“, å¹¶å‘å†™å…¥
		sem: make(chan struct{}, numWorkers),
	}
}

// Start starts a new Runner.
func (w *Workers) Start(ctx context.Context) (Runner, context.Context) {
	g, ctx := errgroup.WithContext(ctx)
	return &amp;errGroupRunner{
		Group: g,
		ctx:   ctx,
		w:     w,
	}, ctx
}

</code></pre>
<p>Playground æµ‹è¯•ç¤ºä¾‹: <a href=https://play.golang.org/p/4AJtyVnlSOd>https://play.golang.org/p/4AJtyVnlSOd</a></p>
<pre><code class=language-go>func main() {
	w := para.New(10)
	runner, _ := w.Start(context.TODO())
	runner.Run(func() error {
		fmt.Println(&quot;fucking&quot;)
		return nil
	})
	time.Sleep(2 * time.Second)
}
</code></pre>
<h3 id=36-æ‡’åŠ è½½>3.6 æ‡’åŠ è½½</h3>
<blockquote>
<p>Lazy åŒ…</p>
</blockquote>
<h4 id=361-oncemore>3.6.1 onceMore</h4>
<pre><code class=language-go>package lazy

import (
	&quot;sync&quot;
	&quot;sync/atomic&quot;
)

// onceMore is similar to sync.Once.
//
// Additional features are:
// * it can be reset, so the action can be repeated if needed
// * it has methods to check if it's done or in progress
//
type onceMore struct {
	mu   sync.Mutex
	lock uint32
	done uint32
}

func (t *onceMore) Do(f func()) {
	if atomic.LoadUint32(&amp;t.done) == 1 {
		return
	}

	// f may call this Do and we would get a deadlock.
	locked := atomic.CompareAndSwapUint32(&amp;t.lock, 0, 1)
	if !locked {
		// æ²¡æœ‰æŠ¢åˆ°åŸå­æ“ä½œ
		return
	}
	// é‡Šæ”¾åŸå­é”
	// defer æ˜¯ FILO, è¯¥åŸå­é”ä¼šæœ€åæ‰é‡Šæ”¾
	defer atomic.StoreUint32(&amp;t.lock, 0)

	// å¹¶å‘é”, ä¿è¯ t.done å€¼çš„è¯»å–ä¸ä¼šäº§ç”Ÿç«äº‰
	t.mu.Lock()
	defer t.mu.Unlock()

	// Double check
	if t.done == 1 {
		return
	}
	defer atomic.StoreUint32(&amp;t.done, 1)
	f()
}

func (t *onceMore) InProgress() bool {
	return atomic.LoadUint32(&amp;t.lock) == 1
}

func (t *onceMore) Done() bool {
	return atomic.LoadUint32(&amp;t.done) == 1
}

func (t *onceMore) ResetWithLock() *sync.Mutex {
	t.mu.Lock()
	defer atomic.StoreUint32(&amp;t.done, 0)
	return &amp;t.mu
}

</code></pre>
<h4 id=362-init>3.6.2 init</h4>
<pre><code class=language-go>package lazy

import (
	&quot;context&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;github.com/pkg/errors&quot;
)

// New creates a new empty Init.
func New() *Init {
	return &amp;Init{}
}

// Init holds a graph of lazily initialized dependencies.
type Init struct {
	mu sync.Mutex // å¹¶å‘ä¿®æ”¹å›¾çš„é”

	prev     *Init
	children []*Init

	init onceMore // ä¿è¯åªæ‰§è¡Œä¸€æ¬¡çš„é”
	out  interface{} // æ‰§è¡Œç»“æœ
	err  error // æ‰§è¡Œé”™è¯¯
	f    func() (interface{}, error) // å›è°ƒå‡½æ•°
}

// Add adds a func as a new child dependency.
func (ini *Init) Add(initFn func() (interface{}, error)) *Init {
	if ini == nil {
		ini = New()
	}
	return ini.add(false, initFn)
}

// AddWithTimeout is same as Add, but with a timeout that aborts initialization.
func (ini *Init) AddWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {
	return ini.Add(func() (interface{}, error) {
		return ini.withTimeout(timeout, f)
	})
}

// Branch creates a new dependency branch based on an existing and adds
// the given dependency as a child.
func (ini *Init) Branch(initFn func() (interface{}, error)) *Init {
	if ini == nil {
		ini = New()
	}
	return ini.add(true, initFn)
}

// BranchdWithTimeout is same as Branch, but with a timeout.
func (ini *Init) BranchWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init {
	return ini.Branch(func() (interface{}, error) {
		return ini.withTimeout(timeout, f)
	})
}

// Do initializes the entire dependency graph.
func (ini *Init) Do() (interface{}, error) {
	if ini == nil {
		panic(&quot;init is nil&quot;)
	}

	// è°ƒç”¨ onceMore åº“ä¿è¯åªæ‰§è¡Œä¸€æ¬¡
	ini.init.Do(func() {
		// è·å–çˆ¶èŠ‚ç‚¹
		prev := ini.prev
		if prev != nil {
			// A branch. Initialize the ancestors.
			// è‹¥çˆ¶èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆåˆå§‹åŒ–, å¹¶ä¸”æ²¡æœ‰æ­£åœ¨æ‰§è¡Œçš„å›è°ƒå‡½æ•°, æ‰§è¡Œ
			if prev.shouldInitialize() {
				_, err := prev.Do()
				if err != nil {
					ini.err = err
					return
				}
			} else if prev.inProgress() {
				// Concurrent initialization. The following init func
				// may depend on earlier state, so wait.
				// ç­‰å¾…ä¸€å®šæ—¶é—´, è‹¥æ²¡æœ‰æ‰§è¡Œå®Œ, panic
				prev.wait()
			}
		}

		// æ‰§è¡Œå›è°ƒå‡½æ•°
		if ini.f != nil {
			ini.out, ini.err = ini.f()
		}

		// å¾ªç¯æ‰§è¡Œå­èŠ‚ç‚¹çš„å›è°ƒå‡½æ•°
		// ä¸ºä»€ä¹ˆä¸å¹¶å‘æ‰§è¡Œ ?
		for _, child := range ini.children {
			if child.shouldInitialize() {
				_, err := child.Do()
				if err != nil {
					ini.err = err
					return
				}
			}
		}
	})

	ini.wait()

	return ini.out, ini.err
}

// TODO(bep) investigate if we can use sync.Cond for this.
func (ini *Init) wait() {
	var counter time.Duration
	for !ini.init.Done() {
		counter += 10
		if counter &gt; 600000000 {
			panic(&quot;BUG: timed out in lazy init&quot;)
		}
		time.Sleep(counter * time.Microsecond)
	}
}

func (ini *Init) inProgress() bool {
	return ini != nil &amp;&amp; ini.init.InProgress()
}

// è‹¥ æ²¡æœ‰æ³¨å†Œäº†å›è°ƒå‡½æ•° | å·²ç»å®Œæˆ | æ­£åœ¨æ‰§è¡Œ, ä¸è¿›è¡Œåˆå§‹åŒ–
func (ini *Init) shouldInitialize() bool {
	return !(ini == nil || ini.init.Done() || ini.init.InProgress())
}

// Reset resets the current and all its dependencies.
func (ini *Init) Reset() {
	mu := ini.init.ResetWithLock()
	defer mu.Unlock()
	for _, d := range ini.children {
		d.Reset()
	}
}

// æ·»åŠ å›¾çš„èŠ‚ç‚¹
func (ini *Init) add(branch bool, initFn func() (interface{}, error)) *Init {
	ini.mu.Lock()
	defer ini.mu.Unlock()

	// å¦‚æœæ˜¯æ–°å»ºåˆ†æ”¯
	if branch {
		return &amp;Init{
			f:    initFn,
			prev: ini, // çˆ¶èŠ‚ç‚¹
		}
	}

	// å¦‚æœæ˜¯æ·»åŠ å­èŠ‚ç‚¹
	// å¦‚æœå·²ç»è¢«æ‰§è¡Œ, panic
	ini.checkDone()
	// æ·»åŠ å­èŠ‚ç‚¹
	ini.children = append(ini.children, &amp;Init{
		f: initFn,
	})

	// é‡Šæ”¾é”
	return ini
}

func (ini *Init) checkDone() {
	if ini.init.Done() {
		panic(&quot;init cannot be added to after it has run&quot;)
	}
}

// callback å‡½æ•°, æœ‰è¶…æ—¶æ—¶é—´
func (ini *Init) withTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) (interface{}, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	// ç¼“å­˜é€šé“, é˜²æ­¢é˜»å¡
	c := make(chan verr, 1)

	go func() {
		v, err := f(ctx)
		select {
		case &lt;-ctx.Done():
			return
		default:
			c &lt;- verr{v: v, err: err}
		}
	}()

	select {
	case &lt;-ctx.Done():
		return nil, errors.New(&quot;timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file.&quot;)
	case ve := &lt;-c:
		return ve.v, ve.err
	}
}

type verr struct {
	v   interface{}
	err error
}

</code></pre>
<p>å‚è€ƒæ–‡ç« ï¼š</p>
<p>[1] <a href=https://imroc.io/posts/kubernetes/analysis-exitcode/>Kubernetes é—®é¢˜å®šä½æŠ€å·§ï¼šåˆ†æ ExitCode - imroc.io|rocçš„åšå®¢|Cloud Native|Kubernetes|Go|Golang</a></p>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2020-12-10" itemprop=datePublished>Dec 10, 2020</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-twitter" href=https://twitter.com/ywwuyi><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M22.46 6c-.77.35-1.6.58-2.46.69C20.88 6.16 21.56 5.32 21.88 4.31 21.05 4.81 20.13 5.16 19.16 5.36 18.37 4.5 17.26 4 16 4c-2.35.0-4.27 1.92-4.27 4.29C11.73 8.63 11.77 8.96 11.84 9.27 8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15.0 1.49.75 2.81 1.91 3.56C3.62 10.5 2.96 10.3 2.38 10V10.03c0 2.08 1.48 3.82 3.44 4.21C5.46 14.34 5.08 14.39 4.69 14.39 4.42 14.39 4.15 14.36 3.89 14.31c.54 1.69 2.11 2.95 4 2.98-1.46 1.16-3.31 1.84-5.33 1.84C2.22 19.13 1.88 19.11 1.54 19.07 3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79 20.33 8.6 20.33 8.42 20.32 8.23 21.16 7.63 21.88 6.87 22.46 6z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206eâ¸€-\u2e7eâº€-\u2efeâ¼€-\u2fdeâ¿°-\u2ffe\u3000-ã€¾\u3040-ã‚ã‚ -ãƒ¾\u3100-\u312e\u3130-ã†ã†-ã†ã† -\u31beã‡€-\u31eeã‡°-ã‡¾ãˆ€-ã‹¾ãŒ€-ã¾ã€-\u4dbeä¸€-\u9ffe\ua960-\ua97eê°€-\ud7ae\ud7b0-\ud7feï¤€-\ufafeï¸°-ï¹\uff00-ï¿®]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>